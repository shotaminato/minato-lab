最近は、仕事でCPUのキャッシュメモリを作成しており、人生で初めての論理合成に挑戦中です。自分の作成したRTLが、初めて論理回路に変換され、感動しました。普段から上司にいわれていたこととして、生成される論理回路を意識しながらRTLを書くことが大事、ということがあったのですが、この結果を受けて初めて実感することができました。

例えば、N bit のコンパレーターの生成回路は、 Nbit X 1段のXOR => log2(N)段のリダクションOR、という形になります。XORは、各ビットが等しければ0を、異なれば1を出力します。これをリダクションORによって、すべてのbitを集めて、出力とします。

また、プライマリエンコーダという回路があります。これは、N bit の入力から、最上位ビットの位置を出力する回路で、N bit のvalid 信号から一つ選択する際に、よく使用します。例えば、以下のようなRTLはプライマリエンコーダとなります。

[source,systemverilog]
----
always_comb begin
    for (int i = 0; i < N; i++) begin
        if (valid[i]) begin
            output = i;
            break;
        end
    end
end
----

ところがこの回路は問題があります。それは、for文のインデックス同士に依存関係があることです。i = m が選ばれるかどうかは、0 <= i <= m-1 のビットがすべて0であるかどうかに依存します。そのため、プライマリエンコーダは、1 + (N/2) + log2(N) 段の論理回路で実装されます。

valid のbitのうち、複数のbitが1になる場面では有効な機構ですが、 valid の bit のうち、一つの bit のみが1になる場合には、この依存関係は無用です。

キャッシュメモリの Tag の hit/miss 判定など、valid の bit のうち、1つのbitが1になる場面では、AND と OR を組み合わせてセレクターを実装するべきです。例えば、以下のような書き方になります。

[source,systemverilog]
----
always_comb begin
    for (int i = 0; i < N; i++) begin
        if (valid[i]) begin
            output |= i;
        end
    end
end
----

この回路のよいところは、for文のインデックス同士に依存関係がなく、並列して処理が可能なことです。つまり、この回路は、最大でも 1 + log2(N) 段の論理回路で実装することができます。プライマリエンコーダでは、16 way のTagArrayは8段の削減となります。

このように、論理合成の結果は、RTLの書き方によって大きく変わります。これを論理合成後に、タイミングチャートを見て、問題箇所を発見し、一つ一つ修正していくのはかなり大変です。そのため、RTLの開発時点で論理回路を意識して記述することが大切です。